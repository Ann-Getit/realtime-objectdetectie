<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>

      #videoContainer {
      position: relative;
      
    }
    
    #switchCamera {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 3;
      background: rgb(181, 135, 224);
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
    }

    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      display: block;
      pointer-events: none;
      z-index: 2;
    }

    #video {
      position: absolute;
      top: 0;
      left: 0;
      width: 640;
      height: 480;
      display: block;
      z-index: 1;
      object-fit: cover;
    }

    </style>
</head>
<body>
  <!--<div id="log" style="white-space: pre-wrap; background: #f0f0f0; padding: 10px; height: 200px; overflow-y: scroll; border: 1px solid #ccc;"></div> -->
  <div id="videoContainer" style="position: relative; display: inline-block;">
  <video id="video" autoplay muted playsinline></video>
  <canvas id="canvas" width="640" height="480"></canvas>
  <button id="switchCamera">Switch Camera</button>
  
</div>
<div id="server-status"></div>

<script>


const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let processing = false;


    let currentFacingMode = 'user'; // start met frontcamera
    let currentStream = null;


    // Open webcam
    function startCamera(facingMode) {
      if (currentStream) {
        currentStream.getTracks().forEach(track => track.stop());
      }


      navigator.mediaDevices.getUserMedia({ video: { facingMode } })
        .then(stream => {
         currentStream = stream;
         video.srcObject = stream;
        video.onplaying = () => console.log("âœ… Video is playing");

        // Wacht tot metadata geladen is (video grootte bekend)
        video.onloadedmetadata = () => {
          video.play(); // zeker weten dat video speelt
            // Start pas frame verwerking als video klaar is
          processFrame(); // start recursieve loop
        };
    })
    .then(() => console.log("âœ… Camera toegang toegestaan"))
    .catch(err => console.error("Camera error:", err));
}

// start met de frontcamera
    startCamera(currentFacingMode);


    function switchCam() {
      document.getElementById('switchCamera').addEventListener('click', () => {
        currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
        startCamera(currentFacingMode);
        console.log('ðŸ”„ Switch Camera pressed!');
      }
    )};
    
    switchCam();

let lastProcessTime = 0; 
const FPS = 3;
let serverOffline = false; //LETOP als detectie enzv niet werkt ondanks false.. vergeet niet startProcessing aan te roepen. 

async function processFrame() {
  const now = performance.now();
    if (now - lastProcessTime < 1000 / FPS) { // niet meer dan 3 fps 
    requestAnimationFrame(processFrame);
    return; // skip frame als vorige nog bezig
    }
    lastProcessTime = now;

    if (processing) { // skip frame als vorige nog bezig 
       requestAnimationFrame(processFrame); 
       return 
    } 
      processing = true;


        // Alleen verder als video ready
    if (video.readyState < 2) { 
        processing = false;
        requestAnimationFrame(processFrame);
        return;
    }

      // Canvas dezelfde grootte als video
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    // Debug: check dat frame getekend is 
       console.log("Frame getekend, width:", canvas.width, "height:", canvas.height);

  // Frame als base64
  try {
      const dataURL = canvas.toDataURL('image/jpeg');
      const base64 = dataURL.split(',')[1];
      if (!base64) { // check nogmaals
        console.warn("Geen frame beschikbaar, skip");
        processing = false;
        requestAnimationFrame(processFrame);
        return;
    }

    if (serverOffline) {
       updateServerStatus();
       processing = false;
       requestAnimationFrame(processFrame);
       return;
    }

      
      // ðŸ”§ Dynamische URL: gebruikt automatisch ngrok of lokale server
     let SERVER_URL = window.location.hostname.includes("ngrok")
        ? `${window.location.origin}/detect`
        : (window.location.hostname === "127.0.0.1" || window.location.hostname === "localhost")
        ? `http://${window.location.hostname}:5050/detect`
        : "https://backend-realtime-server.onrender.com/detect"; // jouw lokale IP als fallback //URL PLAATSEN van backend
       //  Als je lokaal test zonder ngrok, moet je het lokale IP of localhost gebruiken=    : "http://localhost:5050/detect";


      console.log("sending fram to backend, length:", base64.length);
        

     
      const res = await fetch(SERVER_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ image: base64 })
      });


     if (!res.ok) {
         if (res.status === 503 || res.status === 429) {
            serverOffline = true; 
            console.error("Server offline, verdere requests geblokkeerd!");
            console.log("status:", serverOffline);
            updateServerStatus(); //update meteen de UI
         } else {
            const text = await res.text(); // lees de error
            console.warn("Server is offline, stoppen met requests", text);
            await new Promise(resolve => setTimeout(resolve, 500)); // wacht even bij andere errors
         }
         return; // stop hier meteen
      }
      
      const json = await res.json();

      // Check of backend zegt dat je limiet bereikt is
     if (json.error === "limit-reached") {
      serverOffline = true;
      updateServerStatus();
      console.error("âš ï¸ Requestlimiet bereikt â€“ alle requests gestopt!");
      return; 
  }
      if (json.detections) drawDetections(json.detections);
      
} catch (err) {
    console.error("Fetch error:", err);

} finally {
    processing = false;
    if (!serverOffline) {
    requestAnimationFrame(processFrame);
    } else {
        console.log("ðŸ”´ Loop gestopt â€“ server offline / limiet bereikt."); // alleen melding
    }
  }
}

function updateServerStatus() {
const statusDiv = document.getElementById("server-status");
if (!statusDiv) return; // voorkomt fouten als element niet bestaat
statusDiv.textContent = serverOffline
   ? "Server status: offline - requests geblokkeerd"
   : "Server status: online";
}

function startProcessing() {
    processing = false;
    serverOffline = false;
    requestAnimationFrame(processFrame);
}
//HIER MOET : startProcessing();  ALS REQUEST OPNIEUW STARTEN NA DIE 1000 REQ STOP.



    function drawDetections(detections) {
      // Clear canvas overlay
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

        ctx.strokeStyle = 'red';
        ctx.lineWidth = 2;
        ctx.font = '16px Arial';
        ctx.fillStyle = 'purple';

        detections.forEach(det => {
            const [x1, y1, x2, y2] = det.bbox;
            const w = x2 - x1;
            const h = y2 - y1;
            ctx.strokeRect(x1, y1, w, h);
            ctx.fillText(`${det.class} ${Math.round(det.confidence * 100)}%`, x1, y1 - 5);
       });
    }


    /*
    DrawDetections

Je drawDetections clear de canvas en tekent video + bounding boxes. Alles klopt.
Tip: als je bounding boxes te groot zijn voor canvas (door resolutie mismatch), moet je de schaal aanpassen:
    
const scaleX = canvas.width / video.videoWidth;
const scaleY = canvas.height / video.videoHeight;

ctx.strokeRect(x1*scaleX, y1*scaleY, w*scaleX, h*scaleY);
ctx.fillText(`${det.class} ${Math.round(det.confidence * 100)}%`, x1*scaleX, y1*scaleY - 5);
*/


</script>

    
</body>
</html>